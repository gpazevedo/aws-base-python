#!/bin/bash
# =============================================================================
# Generate Example Application Terraform Configuration
# =============================================================================
# This script creates example Terraform files for deploying Lambda functions
# in the terraform/ directory with environment-specific configurations
# =============================================================================

set -e

TERRAFORM_DIR="terraform"
BOOTSTRAP_DIR="bootstrap"
ENVIRONMENTS=("dev" "test" "prod")

echo "ðŸš€ Setting up example application Terraform configuration..."
echo ""

# Check if bootstrap has been initialized
if [ ! -f "$BOOTSTRAP_DIR/terraform.tfvars" ]; then
  echo "âš ï¸  Warning: Bootstrap terraform.tfvars not found"
  echo "   Using default values for examples"
  echo "   You should run bootstrap first: cp bootstrap/terraform.tfvars.example bootstrap/terraform.tfvars"
  echo ""
  PROJECT_NAME="my-project"
  AWS_REGION="us-east-1"
else
  # Read configuration from bootstrap
  PROJECT_NAME=$(grep '^project_name' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  AWS_REGION=$(grep '^aws_region' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_ORG=$(grep '^github_org' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_REPO=$(grep '^github_repo' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
fi

# Set defaults if not found
: ${GITHUB_ORG:="your-org"}
: ${GITHUB_REPO:="your-repo"}

echo "ðŸ“‹ Configuration:"
echo "   Project: $PROJECT_NAME"
echo "   Region: $AWS_REGION"
echo "   GitHub: $GITHUB_ORG/$GITHUB_REPO"
echo ""

# Create terraform directory if it doesn't exist
mkdir -p "$TERRAFORM_DIR/environments"

# =============================================================================
# Create main.tf
# =============================================================================
echo "ðŸ“ Creating terraform/main.tf..."
cat > "$TERRAFORM_DIR/main.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Main Configuration
# =============================================================================
# This file defines the core infrastructure for your application
# Generated by scripts/setup-terraform-lambda.sh
# =============================================================================

terraform {
  required_version = ">= 1.13"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Backend configuration is loaded from environments/*.hcl files
  # Initialize with: terraform init -backend-config=environments/dev-backend.hcl
  backend "s3" {
    # Backend config provided via -backend-config flag
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project     = var.project_name
      Environment = var.environment
      ManagedBy   = "Terraform"
      Repository  = var.github_repo
    }
  }
}

# Get current AWS account ID
data "aws_caller_identity" "current" {}

# Get ECR repository (created by bootstrap)
data "aws_ecr_repository" "app" {
  name = var.ecr_repository_name
}
EOF

# =============================================================================
# Create variables.tf
# =============================================================================
echo "ðŸ“ Creating terraform/variables.tf..."
cat > "$TERRAFORM_DIR/variables.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Variables
# =============================================================================

variable "project_name" {
  description = "Project name (must match bootstrap configuration)"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, test, prod)"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
}

variable "github_repo" {
  description = "GitHub repository name (org/repo)"
  type        = string
}

variable "ecr_repository_name" {
  description = "ECR repository name for Lambda container images"
  type        = string
}

variable "lambda_memory_size" {
  description = "Lambda function memory size in MB"
  type        = number
  default     = 512
}

variable "lambda_timeout" {
  description = "Lambda function timeout in seconds"
  type        = number
  default     = 30
}

variable "lambda_architecture" {
  description = "Lambda function architecture (x86_64 or arm64)"
  type        = string
  default     = "arm64"
}

variable "enable_api_gateway" {
  description = "Enable API Gateway for Lambda functions"
  type        = bool
  default     = true
}

variable "additional_tags" {
  description = "Additional tags to apply to resources"
  type        = map(string)
  default     = {}
}
EOF

# =============================================================================
# Create lambda.tf
# =============================================================================
echo "ðŸ“ Creating terraform/lambda.tf..."
cat > "$TERRAFORM_DIR/lambda.tf" <<'EOF'
# =============================================================================
# Lambda Functions Configuration
# =============================================================================

# Lambda execution role (from bootstrap)
data "aws_iam_role" "lambda_execution" {
  name = "${var.project_name}-lambda-execution-role"
}

# Example Lambda function using container image
resource "aws_lambda_function" "api" {
  function_name = "${var.project_name}-${var.environment}-api"
  role          = data.aws_iam_role.lambda_execution.arn

  # Container image configuration
  package_type = "Image"
  # Using hierarchical tag format: api-{environment}-latest
  image_uri    = "${data.aws_ecr_repository.app.repository_url}:api-${var.environment}-latest"

  # Resource configuration
  memory_size = var.lambda_memory_size
  timeout     = var.lambda_timeout
  architectures = [var.lambda_architecture]

  # Environment variables
  environment {
    variables = {
      ENVIRONMENT   = var.environment
      PROJECT_NAME  = var.project_name
      LOG_LEVEL     = var.environment == "prod" ? "INFO" : "DEBUG"
    }
  }

  # Logging configuration
  logging_config {
    log_format = "JSON"
    log_group  = aws_cloudwatch_log_group.lambda_api.name
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-api"
    Description = "Main API Lambda function"
  }

  # Note: Image must exist in ECR before first apply
  # Build and push via GitHub Actions or manually:
  #   1. Build: cd backend && docker build --build-arg SERVICE_FOLDER=api --platform linux/arm64 -f Dockerfile.lambda -t myapp:latest .
  #   2. Push: Use GitHub Actions workflow or 'make docker-push-dev'
  lifecycle {
    ignore_changes = [
      image_uri  # Allow image updates without Terraform (managed by CI/CD)
    ]
  }
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_api" {
  name              = "/aws/lambda/${var.project_name}-${var.environment}-api"
  retention_in_days = var.environment == "prod" ? 30 : 7

  tags = {
    Name = "${var.project_name}-${var.environment}-api-logs"
  }
}

# Lambda Function URL (alternative to API Gateway)
resource "aws_lambda_function_url" "api" {
  function_name      = aws_lambda_function.api.function_name
  authorization_type = "NONE"  # Change to "AWS_IAM" for authentication

  cors {
    allow_credentials = true
    allow_origins     = ["*"]
    allow_methods     = ["*"]
    allow_headers     = ["*"]
    max_age          = 86400
  }
}
EOF

# =============================================================================
# Create api-gateway.tf (optional)
# =============================================================================
echo "ðŸ“ Creating terraform/api-gateway.tf..."
cat > "$TERRAFORM_DIR/api-gateway.tf" <<'EOF'
# =============================================================================
# API Gateway Configuration (Optional)
# =============================================================================
# Uncomment this file to use API Gateway instead of Lambda Function URLs
# =============================================================================

# API Gateway REST API
resource "aws_api_gateway_rest_api" "api" {
  count = var.enable_api_gateway ? 1 : 0

  name        = "${var.project_name}-${var.environment}-api"
  description = "API Gateway for ${var.project_name} ${var.environment}"

  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# Root resource proxy
resource "aws_api_gateway_resource" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  parent_id   = aws_api_gateway_rest_api.api[0].root_resource_id
  path_part   = "{proxy+}"
}

# ANY method for proxy
resource "aws_api_gateway_method" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id   = aws_api_gateway_rest_api.api[0].id
  resource_id   = aws_api_gateway_resource.proxy[0].id
  http_method   = "ANY"
  authorization = "NONE"
}

# Lambda integration
resource "aws_api_gateway_integration" "lambda" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  resource_id = aws_api_gateway_method.proxy[0].resource_id
  http_method = aws_api_gateway_method.proxy[0].http_method

  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.api.invoke_arn
}

# Deployment
resource "aws_api_gateway_deployment" "api" {
  count = var.enable_api_gateway ? 1 : 0

  depends_on = [
    aws_api_gateway_integration.lambda
  ]

  rest_api_id = aws_api_gateway_rest_api.api[0].id

  lifecycle {
    create_before_destroy = true
  }
}

# Stage
resource "aws_api_gateway_stage" "api" {
  count = var.enable_api_gateway ? 1 : 0

  deployment_id = aws_api_gateway_deployment.api[0].id
  rest_api_id   = aws_api_gateway_rest_api.api[0].id
  stage_name    = var.environment
}

# Lambda permission for API Gateway
resource "aws_lambda_permission" "api_gateway" {
  count = var.enable_api_gateway ? 1 : 0

  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.api[0].execution_arn}/*/*"
}
EOF

# =============================================================================
# Create outputs.tf
# =============================================================================
echo "ðŸ“ Creating terraform/outputs.tf..."
cat > "$TERRAFORM_DIR/outputs.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Outputs
# =============================================================================

output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api.arn
}

output "lambda_function_url" {
  description = "Lambda Function URL endpoint"
  value       = aws_lambda_function_url.api.function_url
}

output "api_gateway_url" {
  description = "API Gateway endpoint URL"
  value       = var.enable_api_gateway ? aws_api_gateway_stage.api[0].invoke_url : "Not enabled"
}

output "cloudwatch_log_group" {
  description = "CloudWatch Log Group name for Lambda"
  value       = aws_cloudwatch_log_group.lambda_api.name
}

output "ecr_repository_url" {
  description = "ECR repository URL for container images"
  value       = data.aws_ecr_repository.app.repository_url
}

output "environment" {
  description = "Current environment"
  value       = var.environment
}
EOF

# =============================================================================
# Create environment-specific tfvars files
# =============================================================================
for ENV in "${ENVIRONMENTS[@]}"; do
  echo "ðŸ“ Creating terraform/environments/${ENV}.tfvars..."

  cat > "$TERRAFORM_DIR/environments/${ENV}.tfvars" <<EOF
# =============================================================================
# Application Infrastructure - ${ENV} Environment
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# Customize these values for your ${ENV} environment
# =============================================================================

project_name = "${PROJECT_NAME}"
environment  = "${ENV}"
aws_region   = "${AWS_REGION}"
github_repo  = "${GITHUB_ORG}/${GITHUB_REPO}"  # From bootstrap configuration

# ECR Repository (created by bootstrap)
ecr_repository_name = "${PROJECT_NAME}"  # Must match bootstrap configuration

# Lambda Configuration
lambda_memory_size  = $([ "$ENV" = "prod" ] && echo "1024" || echo "512")
lambda_timeout      = $([ "$ENV" = "prod" ] && echo "60" || echo "30")
lambda_architecture = "arm64"  # or "x86_64"

# API Gateway (optional - Lambda Function URLs are used by default)
enable_api_gateway = false

# Additional tags
additional_tags = {
  CostCenter = "engineering"
  Team       = "platform"
}
EOF
done

# =============================================================================
# Create README
# =============================================================================
echo "ðŸ“ Creating terraform/README.md..."
cat > "$TERRAFORM_DIR/README.md" <<EOF
# Application Infrastructure

This directory contains Terraform configuration for your application infrastructure.

## Structure

- \`main.tf\` - Main Terraform configuration and provider setup
- \`variables.tf\` - Variable definitions
- \`lambda.tf\` - Lambda function resources
- \`api-gateway.tf\` - API Gateway configuration (optional)
- \`outputs.tf\` - Output values
- \`environments/\` - Environment-specific variable files
  - \`dev.tfvars\` - Development environment
  - \`test.tfvars\` - Test environment
  - \`prod.tfvars\` - Production environment
  - \`*-backend.hcl\` - Backend configurations (generated by \`make setup-terraform-backend\`)

## Prerequisites

1. Bootstrap infrastructure must be deployed first:
   \`\`\`bash
   make bootstrap-create
   make bootstrap-init
   make bootstrap-apply
   make setup-terraform-backend
   \`\`\`

2. Docker image must be built and pushed to ECR:
   \`\`\`bash
   make docker-build
   make docker-push-dev
   \`\`\`

## Usage

### Development Environment

\`\`\`bash
# Initialize Terraform
make app-init-dev

# Plan changes
make app-plan-dev

# Apply changes
make app-apply-dev

# View outputs
cd terraform && terraform output
\`\`\`

### Production Environment

\`\`\`bash
make app-init-prod
make app-plan-prod
make app-apply-prod
\`\`\`

## Customization

1. Edit \`environments/{env}.tfvars\` to customize settings per environment
2. Modify \`lambda.tf\` to add more Lambda functions
3. Enable API Gateway by setting \`enable_api_gateway = true\` in tfvars
4. Add more resources as needed (databases, queues, etc.)

## Notes

- Lambda functions use container images from ECR
- CloudWatch Logs are automatically configured
- Lambda Function URLs are enabled by default (no API Gateway needed)
- First apply will fail if Docker image doesn't exist in ECR
EOF

echo ""
echo "âœ… Application Terraform configuration created successfully!"
echo ""
echo "ðŸ“‚ Created files:"
echo "   terraform/main.tf"
echo "   terraform/variables.tf"
echo "   terraform/lambda.tf"
echo "   terraform/api-gateway.tf"
echo "   terraform/outputs.tf"
echo "   terraform/README.md"
for ENV in "${ENVIRONMENTS[@]}"; do
  echo "   terraform/environments/${ENV}.tfvars"
done
echo ""
echo "âœ… Application Terraform configuration created successfully!"
echo ""
echo "=================================================="
echo "âš ï¸  IMPORTANT: Deploy via GitHub Actions Only"
echo "=================================================="
echo ""
echo "All AWS deployments MUST be done through GitHub Actions."
echo ""
echo "ðŸ“‹ Recommended deployment workflow:"
echo ""
echo "1. Review and customize the generated files:"
echo "   vim terraform/environments/dev.tfvars"
echo "   - Update github_repo with your actual repository"
echo "   - Adjust Lambda memory/timeout settings as needed"
echo ""
echo "2. Ensure bootstrap infrastructure is deployed:"
echo "   make bootstrap-apply"
echo "   make setup-terraform-backend"
echo ""
echo "3. Configure GitHub repository secrets (from bootstrap output):"
echo "   make bootstrap-output  # Shows role ARNs, bucket names"
echo "   - Add AWS_ACCOUNT_ID and AWS_REGION to repository secrets"
echo "   - Add AWS_ROLE_ARN_DEV to dev environment secrets"
echo "   - Add AWS_ROLE_ARN_PROD to production environment secrets"
echo ""
echo "4. Deploy via GitHub Actions:"
echo "   git add ."
echo "   git commit -m 'feat: Add Lambda infrastructure'"
echo "   git push origin main"
echo ""
echo "   GitHub Actions will automatically:"
echo "   - Run tests"
echo "   - Build arm64 Docker image"
echo "   - Push to ECR"
echo "   - Deploy infrastructure with Terraform"
echo "   - Run smoke tests"
echo ""
echo "5. Monitor deployment:"
echo "   https://github.com/<your-org>/<your-repo>/actions"
echo ""
echo "6. Deploy to production (when ready):"
echo "   git tag v1.0.0"
echo "   git push origin v1.0.0"
echo ""
echo "=================================================="
echo "ðŸ’¡ Why use GitHub Actions?"
echo "=================================================="
echo "- âœ… Consistent arm64 builds (no QEMU/emulation issues)"
echo "- âœ… Automated testing before deployment"
echo "- âœ… Complete audit trail of changes"
echo "- âœ… No manual AWS credential management"
echo "- âœ… Reproducible deployments across team"
echo ""
echo "For more details, see: README.md#deploy-to-aws"
echo ""
